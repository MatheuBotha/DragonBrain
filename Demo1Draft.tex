\documentclass[11pt]{article}

\begin{document}

\begin{titlepage}

\begin{center}
\begin{huge}
Swarm Visualiser - COS 301 Main Project
\\
Architecture Requirements and Software Architecture
\begin{small}
\\
Team: Dragon Brain
\\
Members:
\\
Matheu Botha u14284104
\\
Renton McInytre u14312710
\\
Emilio Singh u14006512
\\
Gerard van Wyk u14101263

\end{small}

\end{huge}
\end{center}
\end{titlepage}

\pagebreak

\tableofcontents

\pagebreak
\section{Vision of System}
The vision of the system, as expressed by the client, would be to create a standalone, fully functioning, experimental and teaching tool that brings to life, the functioning of a Particle Swarm Optimisation problem solver coupled to a real time graphical visualiser to display the workings of the Particle Swarm Optimisation problem solver to the user.

\section{Scope of System}
The Swarm Visualiser, as commissioned by Mr Christopher Cleghorn, has two fundamental responsibilities that are encapsulated within a single software program that is deployed to and used from a single computer at a time.

The first responsibility is to provide a underlying, adaptable and fully functioning Particle Swarm Optimisation System that makes use of the Particlce Swarm Optimisation Model or PSO Model to solve problems.

The second responsibility, and the more important one, is to provide a real time graphical visualisation of the PSO as it functions in terms of visualising all essential elements of the PSO as it performs problem solving and then presenting this information to the user in a real time and understandable manner.

To this end, our system is ultimately responsible for providing both the underlying infrastructure in which the PSO will operate but also for providing the interface infrastructure through which the user will access the underlying PSO functionality.


\section{Architectural Requirements}
\subsection{Scope}
In terms of the Architectural Scope of the project, we have a task that requires a minimal reliance on extremal frameworks and APIs. This is on account of the fact that our product is at its core a desktop application designed to be run in an isolated environment. Additionally, the focus on minimal interference requires that we design the system in such a manner that there is as low a possibility of bottlenecking as possible. As such, we will (as far as possible) minimize the technologies being used to standard C++ and OpenGL. Additionally, the system must be designed in such a manner that the Visualizer and the underlying PSO are not tightly coupled. It should be easy to adjust one or the other without making adjustments throughout.
\subsection{Quality Requirements}
\paragraph{Performance}
Performance is arguably the most vital requirement in the system that in the Visualizer's functionality. It can be defined as follows:
\newline\textit{The amount of work accomplished in a measured time interval.}
\newline In our case, we are going to make use of reference to \textbf{latency} and \textbf{frames per second} as a measure of performance, where latency is defined as \textit{a time interval during which a response is achieved given some request} and frames per second, or fps, is defined as \textit{a measurement of how many unique consecutive images can be shown in a graphical context per second}. It should be noted that due to the graphical implications of our task, an important factor in performance is rendering resolution.
\paragraph{•}
As such, the following requirements are set:
\begin{itemize}
	\item The architecture of the design should be efficiently designed such that when a request is issued to the Visualizer, such as changing the objective function, there is a minimal latency involved in generating a response.
	\item The visualizer should be allow at least the following resolutions: 800x600, 1024x789, 1920x1080
	\item Given the maximum resolution 1920x1080, the Visualizer should be capable of running at a consistent 60fps or greater when being run using a mid-tier or above Graphical Processing Unit (for example).
	\item Given the fact that split-screen functionality is to be implemented, this must be done in a manner such that performance is not hindered dramaticall (hence, do not render multiple full resolution images and shrink them post-rendering).
\end{itemize}

\paragraph{Scalability}
Scalability refers to the project's ability to handle a large workload for extended time periods and the methods through which this is dealt. Being an isolated application, the only workloads to be experienced are in terms of internal utilization. Hence, in terms of the task described, potential scalability issues lie within the task of assigning a large number of particles in a particular instance of running. 
\newline However, the system must still be capable of handling a large number of particles in order to achieve a satisfactory result. As such, the requirement in place is that the system should be capable of handling a large (with some upper limit based on hardware limitations) number of particles while still obtaining a good performance result. This will be achieved through effective use of object memory management and design patterns.

\paragraph{Flexibility}
Flexibility is a very important quality requirement for the system. Various pieces of the underlying PSO or Particle Swarm Optimisation system that the Swarm Visualiser is meant to be visualising are dependent on configuration parameters and pluggable components such as Objective Functions. It is important that the system be flexible enough so that users can modify the operational parameters of the system without having to perform major code changes, ideally without having to perform code changes at all.
\paragraph{•}
This is particularly important when you consider that the system should not depend heavily on hard-coded components like objective functions but must rather be able to switch to new ones as and when the client requires it.

\paragraph{Usability}
Usability is another important quality requirement. Ultimately, the system is meant to be used in some capacity as both an experimental tool and a tool for aiding in teaching. Both of these would therefore require that the system be fundamentally easy to use. Some degree of technical competence is assumed on the part of the users,but for the most part, interfacing with the system to access core functionality should not be unintuitive or frustrating. 

\paragraph{•}
An additional aspect of this usability is defined in terms of how usable the interface to perform modifications to the system must be. The system, as envisioned, is meant to be highly configurable and the means by which this is accomplished must be as simple as possible. 

\paragraph{•}
Although not strictly mandated, traditional values of usability design will be considered in order to deliver on a user-friendly interface that supports maximum usability without sacrificing functionality.
\subsection{Integration and Access Channels}
\paragraph{•}
The Swarm Visualiser or Particle Swarm Visualisation System that we are developing has very little in the way of integration requirements in terms of needing to interface and integrate with external services and programs. Rather, the client has expressed a desire for the system to function largely as a self-dependent and standalone system meaning that all of the functionality required by the system will be provided on-site by the program.

\paragraph{•}
That being said, the requirements for the system in terms of access channels is much more important. The client has specified that they wish for a single-point-of-access system. This translates to the provision of a single user interface that the client(s) will use to interact with and express the system's functionality. This single user interface must be designed such that it provides the graphical/visualisation requirements as specified as by the client, such as 4-screen display and support for various screen resolutions, but also must provide an interface through which the client can interact with and access the underlying system.

\paragraph{•}
Further provision for alternative deployment systems, beyond deployment of a single computer-based application, is limited due to the existing hardware demands that are contiguous to the performance requirements of the system.

\section{Architecture Patterns}
\subsection{Layered System}
\paragraph{•}
Why use a layered system?
\item It simplifies the design considerably.
\item It enables different team members to work on different components without being dependant on the progress of the other components.
\item It enables different team members to work at various levels of abstraction.
\item It supports the portability of software artifacts.
\subsubsection{Optimiser layer}
The Optimiser layer will encompass all the functions performed by the generic interchangeable optimisation algorithm that is being visualised. The graphics layer will request information from the optimiser layer at regular intervals in order to render the particles representing the optimiser's current sample points onto the current fitness landscape. The optimiser will act according to what type of optimiser has been selected by the user.
\subsubsection{Graphics Layer}
The Graphics Layer is responsible for using requests from the client layer and the output of the Optimiser Layer to construct a 2D image frames of the 3D scene to be displayed. 
\subsubsection{Client Layer}
The client layer will handle Graphical User Interface elements that the software user will interact with, and will present the output of the Graphics layer(and implicitly the Optimiser layer) to the user. The user will also use the client layer to set parameters of the optimiser layer to determine which fitness landscape will be used, which optimisation algorithm will be used, and also let the user set the optimiser's parameters.
\subsection{Technologies}
\paragraph{•}
OpenGL was chosen as the graphics engine due to the fact that it will work cross-platform, as opposed to DirectX, and many of the CIRG members run Linux machines, as per client stipulations. Since this program is primarily going to be used by them it makes sense to cater for the target market. 
\paragraph{•}
Fruit is a dependency injection framework for C++, loosely inspired by the Guice framework for Java. It uses C++ metaprogramming together with some new C++11 features to detect most injection problems at compile-time. It allows to split the implementation code in "components" (aka modules) that can be assembled to form other components. From a component with no requirements it's then possible to create an injector, that provides an instance of the interfaces exposed by the component. This is a good option for the DI framework as unlike other c++ DI frameworks most of the checks are done at compile-time to try catch the errors early. Another bonus is that the syntax is similar to jUnit so it will be more comfortable to work with initially.

\paragraph{•}
\end{document}
